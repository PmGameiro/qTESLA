package qTESLA;

import java.util.Arrays;

public class CommonFunction {
	
	/***********************************************************************************
	 * Description:	Convert A String to A Byte Array
	 * 
	 * @param		string			The String to Be Converted
	 * 
	 * @return		byteArray		The Generated Byte Array			
	 ***********************************************************************************/
	public static byte[] hexadecimalStringToByteArray (String string) {
		
		byte[] byteArray = new byte[string.length() / 2];
		
		for (int i = 0; i < byteArray.length; i++) {
			
			int index		= i * 2;
			int value		= Integer.parseInt(string.substring (index, index + 2), 16);
			byteArray[i]	= (byte) value;
			
		}
		
		return byteArray;
		
	}
	
	/**********************************************************************************************************
	 * Description:	Checks Whether the Two Parts of Arrays are Equal to Each Other
	 * 
	 * @param		left			Left Array
	 * @param		leftOffset		Starting Point of the Left Array
	 * @param		right			Right Array
	 * @param		rightOffset		Starting Point of the Right Array
	 * @param		length			Length to be Compared from the Starting Point
	 * 
	 * @return		true			Equal
	 *				false			Different
	 ***********************************************************************************************************/
	public static boolean memoryEqual (byte[] left, int leftOffset, byte[] right, int rightOffset, int length) {
		
		if ((leftOffset + length <= left.length) && (rightOffset + length <= right.length)) {
			
			for (int i = 0; i < length; i++) {
				
				if (left[leftOffset + i] != right[rightOffset + i]) {
					
					return false;
					
				}
				
			}
			
			return true;
			
		} else {
			
			return false;
			
		}
		
	}
	
	/****************************************************************************
	 * Description:	Converts 2 Consecutive Bytes in "load" to A Number of "Short"
	 *				from A Known Position
	 * 
	 * @param		load			Source Array
	 * @param		loadOffset		Starting Position
	 * 
	 * @return		A Number of "Short"
	 ****************************************************************************/
	public static short load16 (final byte[] load, int loadOffset) {
		
		short number = 0;
		
		if (load.length - loadOffset >= Short.SIZE / Byte.SIZE) {
		
			for (int i = 0; i < Short.SIZE / Byte.SIZE; i++) {
			
				number ^= (short) (load[loadOffset + i] & 0xFF) << (Byte.SIZE * i);
			
			}
		
		} else {
			
			for (int i = 0; i < load.length - loadOffset; i++) {
				
				number ^= (short) (load[loadOffset + i] & 0xFF) << (Byte.SIZE * i);
			
			}
			
		}
		
		return number;
		
	}
	
	/******************************************************************************
	 * Description:	Converts 4 Consecutive Bytes in "load" to A Number of "Integer"
	 *				from A Known Position
	 * 
	 * @param		load			Source Array
	 * @param		loadOffset		Starting Position
	 * 
	 * @return		A Number of "Integer"
	 ******************************************************************************/
	public static int load32 (final byte[] load, int loadOffset) {
		
		int number = 0;
		
		if (load.length - loadOffset >= Integer.SIZE / Byte.SIZE) {
		
			for (int i = 0; i < Integer.SIZE / Byte.SIZE; i++) {
			
				number ^= (int) (load[loadOffset + i] & 0xFF) << (Byte.SIZE * i);
			
			}
		
		} else {
			
			
			for (int i = 0; i < load.length - loadOffset; i++) {
				
				number ^= (int) (load[loadOffset + i] & 0xFF) << (Byte.SIZE * i);
				
			}
			
		}
		
		return number;
		
	}
	
	/***************************************************************************
	 * Description:	Converts 8 Consecutive Bytes in "load" to A Number of "Long"
	 *				from A Known Position
	 * 
	 * @param		load			Source Array
	 * @param		loadOffset		Starting Position
	 * 
	 * @return		A Number of "Long"
	 ***************************************************************************/
	public static long load64 (final byte[] load, int loadOffset) {
		
		long number = 0L;
		
		if (load.length - loadOffset >= Long.SIZE / Byte.SIZE) {
		
			for (int i = 0; i < Long.SIZE / Byte.SIZE; i++) {
			
				number ^= (long) (load[loadOffset + i] & 0xFF) << (Byte.SIZE * i);
		
			}
		
		} else {
		
			for (int i = 0; i < load.length - loadOffset; i++) {
			
				number ^= (long) (load[loadOffset + i] & 0xFF) << (Byte.SIZE * i);
			
			}
		
		}
		
		return number;
		
	}
	
	/*****************************************************************************
	 * Description:	Converts A Number of "Short" to 2 Consecutive Bytes in "store"
	 *				from a known position
	 * 
	 * @param		store			Destination Array
	 * @param		storeOffset		Starting position
	 * @param		number			Source Number
	 * 
	 * @return		none
	 *****************************************************************************/
	public static void store16 (byte[] store, int storeOffset, short number) {
		
		if (store.length - storeOffset >= Short.SIZE / Byte.SIZE) {
		
			for (int i = 0; i < Short.SIZE / Byte.SIZE; i++) {
			
				store[storeOffset + i] = (byte) ((number >> (Byte.SIZE * i)) & 0xFF);
			
			}
		
		} else {
			
			for (int i = 0; i < store.length - storeOffset; i++) {
				
				store[storeOffset + i] = (byte) ((number >> (Byte.SIZE * i)) & 0xFF);
			
			}
			
		}
		
	}
	
	/*******************************************************************************
	 * Description:	Converts A Number of "Integer" to 4 Consecutive Bytes in "store"
	 * 				from A Known Position
	 * 
	 * @param		store			Destination Array
	 * @param		storeOffset		Starting Position
	 * @param		number:			Source Number
	 * 
	 * @return		none
	 *******************************************************************************/
	public static void store32 (byte[] store, int storeOffset, int number) {
		
		if (store.length - storeOffset >= Integer.SIZE / Byte.SIZE) {
		
			for (int i = 0; i < Integer.SIZE / Byte.SIZE; i++) {
			
				store[storeOffset + i] = (byte) ((number >> (Byte.SIZE * i)) & 0xFF);
			
			}
		
		} else {
			
			for (int i = 0; i < store.length - storeOffset; i++) {
				
				store[storeOffset + i] = (byte) ((number >> (Byte.SIZE * i)) & 0xFF);
				
			}
			
		}
		
	}
	
	/****************************************************************************
	 * Description:	Converts A Number of "Long" to 8 Consecutive Bytes in "store"
	 * 				from A Known Position
	 * 
	 * @param		store			Destination Array
	 * @param		storeOffset		Starting Position
	 * @param		number			Source Number
	 * 
	 * @return		none
	 ****************************************************************************/
	public static void store64 (byte[] store, int storeOffset, long number) {
		
		if (store.length - storeOffset >= Long.SIZE / Byte.SIZE) {
		
			for (int i = 0; i < Long.SIZE / Byte.SIZE; i++) {
			
				store[storeOffset + i] = (byte) ((number >> (Byte.SIZE * i)) & 0xFFL);
			
			}
		
		} else {
			
			for (int i = 0; i < store.length - storeOffset; i++) {
				
				store[storeOffset + i] = (byte) ((number >> (Byte.SIZE * i)) & 0xFFL);
			
			}
			
		}
		
	}
	
	/**************************************************************************************************************************************
	 * Description:	Computes Absolute Value for for Heuristic qTESLA Security Category-1 and Security Category-3 (Option for Size or Speed)
	 **************************************************************************************************************************************/
	public static int absolute (int value) {
		
		return ((value >> 31) ^ value) - (value >> 31);
		
	}
	
	/*****************************************************************************************************************
	 * Description:	Computes Absolute Value for for Provably-Secure qTESLA Security Category-1 and Security Category-3
	 *****************************************************************************************************************/
	public static long absolute (long value) {
		
		return ((value >> 63) ^ value) - (value >> 63);
		
	}
	
	/**********************************************************************************************************
	 * Description:	Computes the Average Number of An Array
	 * 
	 * @param		array			Target Array
	 * 
	 * @return		average			Average Number of the Target Array
	 ***********************************************************************************************************/
	public static double averageNumber (double[] array) {
		
		double sum = 0.0;
		
		for (int i = 0; i < array.length; i++) {
			
			sum += array[i];
			
		}
		
		double average = sum / array.length;
		
		return average;
		
	}
	
	/**********************************************************************************************************
	 * Description:	Computes the Median Number of An Array
	 * 
	 * @param		array			Target Array
	 * 
	 * @return		median			Median Number of the Target Array
	 ***********************************************************************************************************/
	public static double medianNumber (double[] array) {
		
		double median = 0.0;
		
		Arrays.sort(array);
		
		if (array.length % 2 == 0) {
			
			median = (array[array.length / 2 - 1] + array[array.length / 2]) / 2;
			
		} else {
			
			median = array[array.length / 2];
			
		}
		
		return median;
		
	}
	
}